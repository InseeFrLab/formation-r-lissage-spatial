---
title: "Formation analyse urbaine - Travaux pratiques sur R (carroyage, lissage, zones à façon) [Exercice]"
author: "Kim Antunez et Julien Pramil"
date: "11 mars 2021"
output:
  unilur::tutorial_html_solution:
    toc: true
    toc_float: false
    toc_depth: 1
    suffix: ""
    theme: journal
    highlight: kate
    number_sections: no
    number_subsections: no
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
source("global.R")
library(knitr)

## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
               cache=FALSE, #TRUE
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  }
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  }
})

# boxes custom
#remotes::install_github("koncina/unilur")
knitr::opts_template$set(alert = list(box.title = "Watch out!",
                                      box.body = list(fill = "#ffe0d9", colour = "black"),
                                      box.header = list(fill = "#FFAD99", colour = "black"),
                                      box.collapse = NULL,
                                      box.icon = "fa-exclamation-triangle"))
knitr::opts_template$set(solution = list(box.title = "Solution",
                                         box.body = list(fill = "#e6f6e7", colour = "black"),
                                         box.header = list(fill = "#ace1af", colour = "black"),
                                         box.icon = "fa-check-square",
                                         box.collapse = TRUE))
knitr::opts_template$set(information = list(box.title = "Information",
                                            box.body = list(fill = "#bbe8f4", colour = "black"),
                                            box.header = list(fill = "#64c9e6", colour = "black"),
                                            box.icon = "fa-info-circle",
                                            box.collapse = NULL))
knitr::opts_template$set(clues = list(box.title = "Indices",
                                      box.body = list(fill = "#fff9dc", colour = "black"),
                                      box.header = list(fill = "#ffec8b", colour = "black"),
                                      box.icon = "fa-search",
                                      box.collapse = TRUE))
```

# Présentation de l'exercice

Utilisation de données concernant les parkings publics dans le centre-ville de Bordeaux : 

- Présentation des données
- Présentation de la zone d'intérêt

Objectif

Comment travailler ? 

- Connexion au SSPCloud
- Ouvrir un service RStudio
- Nouveau Script

# Partie 0 : installation de la session et importation des données

```{packages, box.title = "Installation des packages", box.body = list(fill = "white"), box.icon = "fa-star"}
Pour cette partie, vous pouvez aller chercher directement la solution ci-dessous (hors programme de cette formation).

Dans un premier temps, on installe tous les packages nécessaires : 

- `dplyr`
- `sf`
- `btb`
- `mapsf`
- `mapview`

Par ailleurs, on installe `aws.s3` pour importer les données stockées sous Minio (solution de stockage de données sous SSPCloud).

Pour information, `mapview` est un package de cartographie produisant des résultats proches de `leaflet`. Il est un peu plus rapide d'utilisation quant il s'agit de produire des résultats simples : notamment, il reprojette automatiquemeent les objets vectoriels que vous souhaitez cartographier. Vous trouverez davantage d'informations à propos [ici](https://r-spatial.github.io/mapview/).


```


```{r echo=TRUE}
## Liste des librairies utilisées
packages <-  c("dplyr","sf","btb","mapsf","mapview","aws.s3")

## Vérifier si la librairie est installée, si non l'installer, puis la charger
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

```




```{donnees, box.title = "Chargement des données", box.body = list(fill = "white"), box.icon = "fa-star"}
Le code ci-dessous permet d'importater les données utilisées dans ce tutoriel. Elles sont stockées sous Minio, dans le "bucket public" : s3/jpramil/diffusion.

Quelques informations concernant ces jeux de données : 

- `parkings.RDS` : table de données géolocalisées concernant les parkings publics dans l'agglomération bordelaise. Pour chaque parking public, voici les variables renseignées : 
    - `ident` : identifiant du parking public
    - `exploit` : exploitant
    - `np_global` : nombre total de places de stationnement
    - `np_pmr` : nombre de places de stationnement pour les personnes à mobilité réduite 
    - `th_heur` : prix horaire
    - `x` : longitude
    - `y` : latitude
    - `epsg` : code EPSE (projection géographique)

Lien vers le téléchargement des [données brutes](https://files.data.gouv.fr/geo-dvf/latest/csv/2021/). 
Informations complémentaires [ici](https://www.data.gouv.fr/fr/datasets/demandes-de-valeurs-foncieres-geolocalisees/)

- `bordeaux_centre.gpkg` : découpage à façon du centre-ville de Bordeaux, réalisé manuellement par les auteurs de ce tutoriel en utilisant le [Geoportail](https://www.geoportail.gouv.fr/).
 
Là encore, il suffit de copier-coller et executer le code ci-dessous dans votre session RStudio.

```

```{r echo=TRUE}
# Charger la source de données (variable nommée dfBase)
parkings <- 
  aws.s3::s3read_using(
    FUN = base::readRDS,
    object = "diffusion/parking.RDS",
    bucket = "jpramil"
    ,
    opts = list("region" = "")
  )

centreBdx <- 
  aws.s3::s3read_using(
    FUN = sf::st_read,
    object = "diffusion/bordeaux_centre.gpkg",
    bucket = "jpramil"
    ,
    opts = list("region" = "")
  )

```

```{genercarte, box.title = "Fonction de cartographie : genercarte", box.body = list(fill = "white"), box.icon = "fa-star"}
Pour visualiser les résultats de vos lissages, on crée une fonction `genercarte` de cartographie s'appuyant sur le package `mapsf`. On pourra réutiliser cette fonction par la suite, et limiter ainsi le nombre de lignes à recopier dans le code à chaque exercice).

Pour importer cette fonction dans votre environnement global, copier-coller et executer le code ci-dessous.
```


```{r echo=TRUE}

genercarte <- function(sfcarLisse,nomvar,nbreaks=5,zone,titre){
  
  mf_init(x=sfcarLisse,theme = "agolalight")
  mf_map(x = sfcarLisse, 
         type = "choro",
         var=nomvar,
         breaks = "quantile",
         nbreaks = nbreaks,
         lwd=1,
         add = TRUE)
  mf_map(x = st_cast(zone[,c("geom")],"MULTILINESTRING"), 
         lwd=4,
         col="black",add = TRUE)
  mf_layout(title = titre,credits = "Insee-DSAU, XXXX, IGN, mapsf")
}


```



# Partie 1 : s'approprier les données

```{exo1, box.title = "Exercice 1", box.body = list(fill = "white"), box.icon = "fa-star"}
Répondre aux questions suivantes : 

- Combien de parkings publics sont répertoriés dans la base `parkings` ?
- Vérifier qu'il n'y a pas de données manquantes dans les variables de position géographiques.
- Regarder la distribution des variables (avec la fonction `base::summary`)

```

```{r exo1solu, echo=TRUE, solution=TRUE}
head(parkings)
nrow(parkings) 
# 87 parkings dans la base

# Absence de valeurs manquantes dans les xy ? => Vrai
sum(is.na(parkings$x))
sum(is.na(parkings$y))

# Distribution des variables
parkings %>% summary()
```

```{exo2, box.title = "Exercice 2", box.body = list(fill = "white"), box.icon = "fa-star"}
Observer l'emprise du contour du centre-ville de Bordeaux en utilisant la fonction `mapview::mapview` (avec un fond de carte OpenStreetMap).

```

```{exo2clue, opts.label = "clues"}
Il suffit d'écrire `mapview(tableVectorielleSouhaitee)`
```

```{r exo2solu, echo=TRUE, solution=TRUE}
mapview(centreBdx)
```

```{exo3, box.title = "Exercice 3", box.body = list(fill = "white"), box.icon = "fa-star"}
- Transformer la base des parkings en format vectoriel et enregistrer la résultat dans la nouvelle variable `sfparking`:
- Cartographier conjointement le contour de Bordeaux-centre et les parkings en utilisant `mapview`.
```

```{exo3clue, opts.label = "clues"}
- Transformer la base des parkings en format vectoriel et enregistrer la résultat dans la nouvelle variable `sfparking`:
  - Utiliser la fonction `sf::st_as_sf`
  - Attention à bien renseigner le système de projection des coordonnées xy dans le paramètre `crs`.
- Cartographier conjointement le contour de Bordeaux-centre et les parkings de la base :
  - On additionne les couches vectorielles avec "+" : `mapview(polygone)+mapview(points)` 
```

```{r exo3solu,echo=TRUE, solution=TRUE}
# Transformation en objet vectoriel (géographique)
sfparking <- sf::st_as_sf(parkings,coords=c("x","y"),crs=2154)

# Cartographie avec leaflet
mapview(centreBdx)+mapview(sfparking,col.region="black")
```


# Partie 2 : Carroyer les données avant de lisser

Dans le cas présent, le petit nombre de parkings ne rend pas indispensable cette phase de carroyage.
Elle permet néanmoins de s'approprier un peu plus la structure spatiale des données avec le lissage. 

```{exo4, box.title = "Exercice 4", box.body = list(fill = "white"), box.icon = "fa-star"}
- Créer une variable `iCellSize <- 1000` correspondant à la taille des carreaux souhaités
- Créer la table `centroides` des centroïdes des carreaux de 1000m :
  - À partir de la table `parkings`
  - En faisant des "modulo 1000" sur les coordonnées x et y
  - Comptabiliser le nombre de parkings`contenus dans chaque carreau (nouvelle variable `nbParkings`)


```

```{exo5clue, opts.label = "clues"}
On peut créer de nouvelles variables x_centroide et y_centroide correspondant respectivement à x et y auxquelles : 
  - On retire le reste de leurs divisions euclidiennes de x modulo 1000 (respectivmeent y modulo 1000)
  - A ce stade, x_centroide et y_centroide détermine le point en bas à gauche du carreau de 1km
  - et on ajoute 1000/2 pour tomber sur le centre du carreau

A chaque parking est maintenant associé le couple x_centroide et y_centroide du carreau de 1km auquel le parking appartient.
En groupant la base de parkings sur le couple de centroides, on aboutit à la base souahitée.
```


```{r exo4solu, echo=TRUE, solution=TRUE}
# Taille des carreaux
iCellSize = 1000 

centroides <- parkings
centroides$x_centroide = as.integer(floor(centroides$x / iCellSize) * iCellSize + (iCellSize / 2))
centroides$y_centroide = as.integer(floor(centroides$y / iCellSize) * iCellSize + (iCellSize / 2))

# Compter le nombre de parkings par carreau
centroides <- centroides %>% 
  group_by(x=x_centroide,y=y_centroide) %>% 
  count(name = "nbParkings")


```

```{exo5, box.title = "Exercice 5", box.body = list(fill = "white"), box.icon = "fa-star"}
- Transformer `centroides` en grille de carreaux grâce à la fonction `btb::dfToGrid` (et stocker le résultat dans la variable `sfcarreaux`)
- Restreindre cette base aux seuls carreaux intersectant le centre de Bordeaux
- Cartographie les carreaux et le contour du centre de Bordeaux avec `mapview`. 
- Colorier les carreaux différemment selon le nombre de parkings qu'ils contiennent.
```

```{exo5clue, opts.label = "clues"}
Dans la fonction `mapview`, on peut utiliser les options : 
  - zcol = "nbParkings"
  - col.regions=list("grey","yellow","red")
```

```{r exo5solu, echo=TRUE, solution=TRUE}
# Générer la grille
sfcarreaux <- btb::dfToGrid(df = centroides, sEPSG = "2154", iCellSize = iCellSize)

# Restriction du champ : on ne retient que les carreaux intersectant Bordeaux-centre
sfcarreaux <- sfcarreaux[unlist(st_intersects(centreBdx,sfcarreaux)),]

# Cartographie
mapview(centreBdx,alpha.regions=0,lwd=4,legend=F)+mapview(sfcarreaux,zcol = "nbParkings",col.regions=list("grey","yellow","red"))
```


# Partie 3 : Lissage de la densité des parkings

```{exo6, box.title = "Exercice 6", box.body = list(fill = "white"), box.icon = "fa-star"}
- Créer un "buffer" du centre-ville de Bordeaux (avec une marge de 2000m autour) et enregistrer le résultat dans `centreBdxBuffer`
- Sélectionner les parking intersectant cette zone tampon et enregistrer la nouvelle table `parkingBuff`
```

```{r echo=TRUE, solution=TRUE}
# Création d'un buffer autour du territoire
centreBdxBuffer <- st_buffer(centreBdx, dist = 2000)

# Représentation 
mapview(centreBdxBuffer,col.region="gray")+mapview(centreBdx)

# Repérer les indices des observations contenues dans notre buffer d'intérêt
indiceObsContenues <- unlist(sf::st_contains(centreBdxBuffer, sfparking))

# Réduire la base aux seules observations dans le territoire
parkingBuff <- parkings[indiceObsContenues, ]

parkingBuff$nbObsLisse <- 1L

parkingsLissage <- parkingBuff[,c("nbObsLisse","x","y")]
sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="nbObsLisse",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")




```

```{exo7, box.title = "Exercice 7", box.body = list(fill = "white"), box.icon = "fa-star"}
- Créer une variable nbObsLisse = 1L
- Lisser le nombre de parking dans le buffer du centre-ville de Bordeaux : 
    - Avec un rayon de lissage de 1500m
    - En générant une grille carroyée de 200m de côté
- Restreindre les carreaux de 200m obtenus aux seuls intersectant le centre-ville et enregistrer le résultat dans `sfcarLisse`
- Cartographier le résultat obtenu avec la fonction `genercarte` (chargée dans votre environnement global)

```

```{r exo7solu,echo=TRUE, solution=TRUE}

parkingBuff$nbObsLisse <- 1L

parkingsLissage <- parkingBuff[,c("nbObsLisse","x","y")]
sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="nbObsLisse",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")




```


# Excercice 4 : Lissage du nombre de places de parkings

```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_global","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)


# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="np_global",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```


```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_pmr","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)


# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="np_pmr",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```



# Excercice 6 : Lissage de ratios

```{r echo=TRUE, solution=TRUE}

parkingsLissage <- parkingBuff[,c("nbObsLisse","np_global","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse <- sfcarLisse %>% mutate(place_par_parking=np_global/nbObsLisse)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="place_par_parking",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```


```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_global","np_pmr","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse$part_pmf <- sfcarLisse$np_pmr/sfcarLisse$np_global

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="part_pmf",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```




# Excercice 8 (bonus) : où trouver des places de parking pas cher ?



```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("nbObsLisse","th_heur","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse$prix_moyen <- sfcarLisse$th_heur/sfcarLisse$nbObsLisse

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="prix_moyen",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```




```{r echo=TRUE, solution=TRUE}

parkingBuff <- parkingBuff %>% mutate(prix_x_place=np_global*th_heur)

parkingsLissage <- parkingBuff[,c("np_global","prix_x_place","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse <- sfcarLisse %>% mutate(prix_moyen_place=prix_x_place/np_global)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="prix_moyen_place",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```


# Exercice type 

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

```

```{block, opts.label = "clues"}
Indices
```

```{block, solution = TRUE}
Solution sans code
```

```{r echo=TRUE, solution=TRUE}

```



--------------------------------------------

--------------------------------------------

**Reproducibilité**

```{r}
sessionInfo()
```

