---
title: "Formation analyse urbaine - Travaux pratiques sur R (carroyage, lissage, zones à façon) [Exercice]"
author: "Kim Antunez et Julien Pramil"
date: "11 mars 2021"
output:
  unilur::tutorial_html_solution:
    toc: true
    toc_float: false
    toc_depth: 1
    suffix: ""
    theme: journal
    highlight: kate
    number_sections: no
    number_subsections: no
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
source("global.R")
library(knitr)

## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
               cache=FALSE, #TRUE
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  }
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  }
})

# boxes custom
#remotes::install_github("koncina/unilur")
knitr::opts_template$set(alert = list(box.title = "Watch out!",
                                      box.body = list(fill = "#ffe0d9", colour = "black"),
                                      box.header = list(fill = "#FFAD99", colour = "black"),
                                      box.collapse = NULL,
                                      box.icon = "fa-exclamation-triangle"))
knitr::opts_template$set(solution = list(box.title = "Solution",
                                         box.body = list(fill = "#e6f6e7", colour = "black"),
                                         box.header = list(fill = "#ace1af", colour = "black"),
                                         box.icon = "fa-check-square",
                                         box.collapse = TRUE))
knitr::opts_template$set(information = list(box.title = "Information",
                                            box.body = list(fill = "#bbe8f4", colour = "black"),
                                            box.header = list(fill = "#64c9e6", colour = "black"),
                                            box.icon = "fa-info-circle",
                                            box.collapse = NULL))
knitr::opts_template$set(clues = list(box.title = "Indices",
                                      box.body = list(fill = "#fff9dc", colour = "black"),
                                      box.header = list(fill = "#ffec8b", colour = "black"),
                                      box.icon = "fa-search",
                                      box.collapse = TRUE))
```

# Présentation de l'exercice

Utilisation de données concernant les parkings publics dans le centre-ville de Bordeaux : 

- Présentation des données
- Présentation de la zone d'intérêt

Objectif

Comment travailler ? 

- Connexion au SSPCloud
- Ouvrir un service RStudio
- Nouveau Script

# Partie 0 : installation de la session et importation des données

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Pour cette partie, vous pouvez aller chercher directement la solution ci-dessous (hors programme de cette formation).

Dans un premier temps, on installe tous les packages nécessaires : 

- `dplyr`
- `sf`
- `btb`
- `mapsf`
- `mapview`

Par ailleurs, on installe `aws.s3` pour importer les données stockées sous Minio (solution de stockage de données sous SSPCloud).

Pour information, `mapview` est un package de cartographie produisant des résultats proches de `leaflet`. Il est un peu plus rapide d'utilisation quant il s'agit de produire des résultats simples : notamment, il reprojette automatiquemeent les objets vectoriels que vous souhaitez cartographier. Vous trouverez davantage d'informations à propos [ici](https://r-spatial.github.io/mapview/).


```


```{r echo=TRUE}
## Liste des librairies utilisées
packages <-  c("dplyr","sf","btb","mapsf","mapview","aws.s3")

## Vérifier si la librairie est installée, si non l'installer, puis la charger
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

```




```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Le code ci-dessous permet d'importater les données utilisées dans ce tutoriel. Elles sont stockées sous Minio, dans le "bucket public" : s3/jpramil/diffusion.

Quelques informations concernant ces jeux de données : 

- `parkings.RDS` : table de données géolocalisées concernant les parkings publics dans l'agglomération bordelaise. Pour chaque parking public, voici les variables renseignées : 
    - `ident` : identifiant du parking public
    - `exploit` : exploitant
    - `np_global` : nombre total de places de stationnement
    - `np_pmr` : nombre de places de stationnement pour les personnes à mobilité réduite 
    - `th_heur` : prix horaire
    - `x` : longitude
    - `y` : latitude
    - `epsg` : code EPSE (projection géographique)
, avec leurs coordonnées xy. Lien vers le téléchargement des [données brutes](https://files.data.gouv.fr/geo-dvf/latest/csv/2021/). Informations complémentaires [ici](https://www.data.gouv.fr/fr/datasets/demandes-de-valeurs-foncieres-geolocalisees/)
- `bordeaux_centre.gpkg` : découpage à façon du centre-ville de Bordeaux. Découpages réalisés manuellement par les auteurs de ce tutoriel en utilisant le [Geoportail](https://www.geoportail.gouv.fr/).

Là encore, il suffit de copier-coller et executer le code ci-dessous dans votre session RStudio.

```

```{r echo=TRUE}

# Charger la source de données (variable nommée dfBase)
parkings <- 
  aws.s3::s3read_using(
    FUN = base::readRDS,
    object = "diffusion/parking.RDS",
    bucket = "jpramil"
    ,
    opts = list("region" = "")
  )

centreBdx <- 
  aws.s3::s3read_using(
    FUN = sf::st_read,
    object = "diffusion/bordeaux_centre.gpkg",
    bucket = "jpramil"
    ,
    opts = list("region" = "")
  )

```

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Importer cette fonction dans votre environnement global.
Pour visualiser les résultats de vos lissages, on crée une fonction générique de cartographie s'appuyant sur le package `mapsf`. On pourra réutiliser cette fonction par la suite, et limiter ainsi le nombre de lignes à recopier dans le code à chaque exercice).

```


```{r echo=TRUE}

genercarte <- function(sfcarLisse,nomvar,nbreaks=5,zone,titre){
  
  mf_init(x=sfcarLisse,theme = "agolalight")
  mf_map(x = sfcarLisse, 
         type = "choro",
         var=nomvar,
         breaks = "quantile",
         nbreaks = nbreaks,
         lwd=1,
         add = TRUE)
  mf_map(x = st_cast(zone[,c("geom")],"MULTILINESTRING"), 
         lwd=4,
         col="black",add = TRUE)
  mf_layout(title = titre,credits = "Insee-DSAU, XXXX, IGN, mapsf")
}


```



# Partie 1 : s'approprier les données

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Répondre aux questions suivantes : 

- Combien de parkings publics concernés dans la base ?
- Vérifier qu'il n'y a pas de données manquantes dans les variables de position géographiques.

```
```{r echo=TRUE, solution=TRUE}
head(parkings)
nrow(parkings) # 87 parkings dans la base

# Absence de valeurs manquantes dans les xy 
sum(is.na(parkings$x))
sum(is.na(parkings$y))

```

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Observer l'emprise du contour du centre-ville de Bordeaux.
Pour cela : 
- Créer une nouvelle base `centreBdx_4326` correspondant à une reprojection de `centreBdx` en coordonnées WGS84 (à l'aide de la fonction `sf::st_transform`) ;
- Cartographier `centreBdx_4326` à l'aide de la fonction `leaflet::leaflet` (avec un fond de carte OpenStreetMap).
```

```{r echo=TRUE, solution=TRUE}
# Reprojection
centreBdx_4326 <- centreBdx %>% st_transform(4326)

# Cartographie avec leaflet
# leaflet(data=centreBdx_4326) %>% addTiles() %>% addPolygons()
mapview(centreBdx_4326)
```

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

- Transformer la base des parkings en format vectoriel (dans une nouvelle variable `sfparking`) :
- Créer `sfparking4326` : les points `sfparking` reprojetés en WGS84 (code 4326)
- Cartographier conjointement le contour de Bordeaux-centre et les parkings de la base :
```

```{block, opts.label = "clues"}
- Transformer la base des parkings en format vectoriel (dans une nouvelle variable `sfparking`) :
  - Utiliser la fonction `sf::st_as_sf`
  - Attention à bien renseigner le système de projection des coordonnées xy dans le paramètre `crs`.
- Créer `sfparking4326` : les points `sfparking` reprojetés en WGS84 (code 4326)
- Cartographier conjointement le contour de Bordeaux-centre et les parkings de la base :
  - Utiliser Leaflet
  - Reprendre le code de l'exercice précédent en ajouter la couche de points avec `leaflet::addMarkers`
```

```{r echo=TRUE, solution=TRUE}
# Transformation en objet vectoriel (géographique)
sfparking <- sf::st_as_sf(parkings,coords=c("x","y"),crs=2154)

# Reprojection
sfparking4326 <- sfparking %>% st_transform(4326)

# Cartographie avec leaflet
# leaflet() %>% 
#   addTiles() %>% 
#   addPolygons(data = centreBdx_4326) %>% 
#   addMarkers(data = sfparking4326)
mapview(centreBdx_4326,col.region="yellow")+mapview(sfparking4326)
```


# Exercice 2 : Carroyer les données avant de lisser


```{r echo=TRUE, solution=TRUE}
iCellSize = 1000 
points_carroyage <- parkings
points_carroyage$x_centroide = as.integer(floor(points_carroyage$x / iCellSize) * iCellSize + (iCellSize / 2))
points_carroyage$y_centroide = as.integer(floor(points_carroyage$y / iCellSize) * iCellSize + (iCellSize / 2))

# Compter le nombre de parkings par carreau
points_carroyage <- points_carroyage %>% 
  group_by(x=x_centroide,y=y_centroide) %>% 
  count(name = "nbParkings")

# Générer la grille
points_carroyage <- btb::dfToGrid(df = points_carroyage, sEPSG = "2154", iCellSize = iCellSize)

# Restriction du champ : on ne retient que les carreaux intersectant Bordeaux-centre
points_carroyage <- points_carroyage[unlist(st_intersects(centreBdx,points_carroyage)),]


mapview(centreBdx,alpha.regions=0,lwd=4,legend=F)+mapview(points_carroyage,zcol = "nbParkings",col.regions=list("grey","yellow","red"))




```


# Excercice 3 : Lissage de la densité de parkings

```{r echo=TRUE, solution=TRUE}
# Création d'un buffer autour du territoire
centreBdxBuffer <- st_buffer(centreBdx, dist = 2000)

# Repérer les indices des observations contenues dans notre buffer d'intérêt
indiceObsContenues <- unlist(sf::st_contains(centreBdxBuffer, sfparking))

# Réduire la base aux seules observations dans le territoire
parkingBuff <- parkings[indiceObsContenues, ]

parkingBuff$nbObsLisse <- 1L

parkingsLissage <- parkingBuff[,c("nbObsLisse","x","y")]
sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="nbObsLisse",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")




```




# Excercice 4 : Lissage du nombre de places de parkings

```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_global","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)


# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="np_global",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```


```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_pmr","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)


# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="np_pmr",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```



# Excercice 6 : Lissage de ratios

```{r echo=TRUE, solution=TRUE}

parkingsLissage <- parkingBuff[,c("nbObsLisse","np_global","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse <- sfcarLisse %>% mutate(place_par_parking=np_global/nbObsLisse)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="place_par_parking",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```


```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_global","np_pmr","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse$part_pmf <- sfcarLisse$np_pmr/sfcarLisse$np_global

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="part_pmf",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```




# Excercice 8 (bonus) : où trouver des places de parking pas cher ?



```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("nbObsLisse","th_heur","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse$prix_moyen <- sfcarLisse$th_heur/sfcarLisse$nbObsLisse

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="prix_moyen",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```




```{r echo=TRUE, solution=TRUE}

parkingBuff <- parkingBuff %>% mutate(prix_x_place=np_global*th_heur)

parkingsLissage <- parkingBuff[,c("np_global","prix_x_place","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse <- sfcarLisse %>% mutate(prix_moyen_place=prix_x_place/np_global)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
genercarte(sfcarLisse=sfcarLisse,
                       nomvar="prix_moyen_place",
                       nbreaks=5,
                       zone=centreBdx,
                       titre="Lissage avec rayon de 1000m")

```


# Exercice type 

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

```

```{block, opts.label = "clues"}
Indices
```

```{block, solution = TRUE}
Solution sans code
```

```{r echo=TRUE, solution=TRUE}

```



--------------------------------------------

--------------------------------------------

**Reproducibilité**

```{r}
sessionInfo()
```

