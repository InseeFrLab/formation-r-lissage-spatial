---
title: "Formation analyse urbaine - Travaux pratiques sur R (carroyage, lissage, zones à façon) [Exercice]"
author: "Kim Antunez et Julien Pramil"
date: "11 mars 2021"
output:
  unilur::tutorial_html_solution:
    toc: true
    toc_float: false
    toc_depth: 1
    suffix: ""
    theme: journal
    highlight: kate
    number_sections: no
    number_subsections: no
---

```{r knitr_init, echo=FALSE, cache=FALSE, include=FALSE}
if (!require("unilur", character.only = TRUE)) {
      install.packages("unilur", dependencies = TRUE)
      library("unilur", character.only = TRUE)
    }
library(knitr)

## Global options
options(max.print="90")
opts_chunk$set(echo=TRUE,
               cache=FALSE, #TRUE
               prompt=FALSE,
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=90)
options(width = 90)

# no margins
knit_hooks$set(nm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,0,0))
  }
})

# title margins
knit_hooks$set(sm = function(before, options, envir){
  if (before){
    par(mar=c(0,0,1.2,0))
  }
})

# boxes custom
#remotes::install_github("koncina/unilur")
knitr::opts_template$set(alert = list(box.title = "Watch out!",
                                      box.body = list(fill = "#ffe0d9", colour = "black"),
                                      box.header = list(fill = "#FFAD99", colour = "black"),
                                      box.collapse = NULL,
                                      box.icon = "fa-exclamation-triangle"))
knitr::opts_template$set(solution = list(box.title = "Solution",
                                         box.body = list(fill = "#e6f6e7", colour = "black"),
                                         box.header = list(fill = "#ace1af", colour = "black"),
                                         box.icon = "fa-check-square",
                                         box.collapse = TRUE))
knitr::opts_template$set(information = list(box.title = "Information",
                                            box.body = list(fill = "#bbe8f4", colour = "black"),
                                            box.header = list(fill = "#64c9e6", colour = "black"),
                                            box.icon = "fa-info-circle",
                                            box.collapse = NULL))
knitr::opts_template$set(clues = list(box.title = "Indices",
                                      box.body = list(fill = "#fff9dc", colour = "black"),
                                      box.header = list(fill = "#ffec8b", colour = "black"),
                                      box.icon = "fa-search",
                                      box.collapse = TRUE))
```

# Présentation de l'exercice

Utilisation de données concernant les parkings publics dans le centre-ville de Bordeaux : 

- Présentation des données
- Présentation de la zone d'intérêt

Objectif

Comment travailler ? 

- Connexion au SSPCloud
- Ouvrir un service RStudio
- Nouveau Script

# Exercice 0 : installation de la session et importation des données

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Pour cette partie, vous pouvez aller chercher directement la solution ci-dessous (hors programme)

Installation des packages suivants : 

- dplyr
- sf
- btb
- mapsf
- leaflet

Par ailleurs, on installe `aws.s3` pour importer les données stockées sous Minio (solution de stockage de données sous SSPCloud)
```


```{r echo=TRUE, solution=TRUE}
## Liste des librairies utilisées
packages <-  c("dplyr","sf","btb","mapsf","leaflet","aws.s3")

## Vérifier si la librairie est installée, si non l'installer, puis la charger
package.check <- lapply(
  packages,
  FUN = function(x) {
    if (!require(x, character.only = TRUE)) {
      install.packages(x, dependencies = TRUE)
      library(x, character.only = TRUE)
    }
  }
)

```




```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Hors formation : il suffit de recopier la solution.
Importation des données stockées sous Minio, dans le "bucket public" : s3/jpramil/diffusion.

- `parkings.RDS` : données sur les parkings publics, avec leurs coordonnées xy
- `bordeaux_centre.gpkg` : découpage à façon du centre-ville de Bordeaux

```

```{r echo=TRUE, solution=TRUE}

# Charger la source de données (variable nommée dfBase)
parkings <- 
  aws.s3::s3read_using(
    FUN = base::readRDS,
    object = "diffusion/parking.RDS",
    bucket = "jpramil"
    ,
    opts = list("region" = "")
  )

centreBdx <- 
  aws.s3::s3read_using(
    FUN = sf::st_read,
    object = "diffusion/bordeaux_centre.gpkg",
    bucket = "jpramil"
    ,
    opts = list("region" = "")
  )
# Visualiser les premières lignes de la base
head(parkings)
head(centreBdx)
```



# Exercice 1 : Prendre connaissance des données

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Répondre aux questions suivantes : 

- Combien de parkings publics concernés dans la base ?
- Vérifier qu'il n'y a pas de données manquantes dans les variables de position géographiques.

```
```{r echo=TRUE, solution=TRUE}
head(parkings)
nrow(parkings) # 87 parkings dans la base

# Absence de valeurs manquantes dans les xy 
sum(is.na(parkings$x))
sum(is.na(parkings$y))

```

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

Observer l'emprise du contour du centre-ville de Bordeaux.
Pour cela : 
- Créer une nouvelle base `centreBdx_4326` correspondant à une reprojection de `centreBdx` en coordonnées WGS84 (à l'aide de la fonction `sf::st_transform`) ;
- Cartographier `centreBdx_4326` à l'aide de la fonction `leaflet::leaflet` (avec un fond de carte OpenStreetMap).
```

```{r echo=TRUE, solution=TRUE}
# Reprojection
centreBdx_4326 <- centreBdx %>% st_transform(4326)

# Cartographie avec leaflet
leaflet(data=centreBdx_4326) %>% addTiles() %>% addPolygons()

```

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

- Transformer la base des parkings en format vectoriel (dans une nouvelle variable `sfparking`) :
- Créer `sfparking4326` : les points `sfparking` reprojetés en WGS84 (code 4326)
- Cartographier conjointement le contour de Bordeaux-centre et les parkings de la base :
```

```{block, opts.label = "clues"}
- Transformer la base des parkings en format vectoriel (dans une nouvelle variable `sfparking`) :
  - Utiliser la fonction `sf::st_as_sf`
  - Attention à bien renseigner le système de projection des coordonnées xy dans le paramètre `crs`.
- Créer `sfparking4326` : les points `sfparking` reprojetés en WGS84 (code 4326)
- Cartographier conjointement le contour de Bordeaux-centre et les parkings de la base :
  - Utiliser Leaflet
  - Reprendre le code de l'exercice précédent en ajouter la couche de points avec `leaflet::addMarkers`
```

```{r echo=TRUE, solution=TRUE}
# Transformation en objet vectoriel (géographique)
sfparking <- sf::st_as_sf(parkings,coords=c("x","y"),crs=2154)

# Reprojection
sfparking4326 <- sfparking %>% st_transform(4326)

# Cartographie avec leaflet
leaflet() %>% 
  addTiles() %>% 
  addPolygons(data = centreBdx_4326) %>% 
  addMarkers(data = sfparking4326)

```


# Exercice 2 : Carroyer 


```{r echo=TRUE, solution=TRUE}
iCellSize = 500 
points_carroyage <- parkings
points_carroyage$x_centroide = as.integer(floor(points_carroyage$x / iCellSize) * iCellSize + (iCellSize / 2))
points_carroyage$y_centroide = as.integer(floor(points_carroyage$y / iCellSize) * iCellSize + (iCellSize / 2))

# Compter le nombre de parkings par carreau
points_carroyage <- points_carroyage %>% 
  group_by(x=x_centroide,y=y_centroide) %>% 
  count(name = "nbParkings")

# Générer la grille
points_carroyage <- btb::dfToGrid(df = points_carroyage, sEPSG = "2154", iCellSize = iCellSize)

# Restriction du champ : on ne retient que les carreaux intersectant Bordeaux-centre
points_carroyage <- points_carroyage[unlist(st_intersects(centreBdx,points_carroyage)),]



# Cartographie

mf_init(x=points_carroyage,theme = "agolalight")
mf_map(x = points_carroyage,
       type = "typo",
       var="nbParkings",
       pal = "Greens",
       # breaks = c(0,1,2,3,4),
       # nbreaks = 2,
       lwd=1,
       # leg_val_rnd = 1,
       add = TRUE)
mf_map(x = st_cast(centreBdx[,c("geom")],"MULTILINESTRING"),
       lwd=4,
       col="black",add = TRUE)
mf_layout(title = "Carroyage du nombre de ventes",credits = "Insee-DSAU, DGFiP, Etalab, IGN, mapsf")


```


# Excercice 3 : Lissage de la densité de parkings

```{r echo=TRUE, solution=TRUE}
# Création d'un buffer autour du territoire
centreBdxBuffer <- st_buffer(centreBdx, dist = 2000)

# Repérer les indices des observations contenues dans notre buffer d'intérêt
indiceObsContenues <- unlist(sf::st_contains(centreBdxBuffer, sfparking))

# Réduire la base aux seules observations dans le territoire
parkingBuff <- parkings[indiceObsContenues, ]

parkingBuff$nbObsLisse <- 1L

parkingsLissage <- parkingBuff[,c("nbObsLisse","x","y")]
sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
mf_init(x=sfcarLisse,theme = "agolalight")
mf_map(x = sfcarLisse, 
       type = "choro",
       var="nbObsLisse",
       breaks = "quantile",
       nbreaks = 5,
       lwd=1,
       add = TRUE)
mf_map(x = st_cast(centreBdx[,c("geom")],"MULTILINESTRING"), 
       lwd=4,
       col="black",add = TRUE)
mf_layout(title = "Lissage avec rayon de 1000m",credits = "Insee-DSAU, XXXX, IGN, mapsf")
```




# Excercice 4 : Lissage du nombre de places de parkings

```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_global","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)


# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
mf_init(x=sfcarLisse,theme = "agolalight")
mf_map(x = sfcarLisse, 
       type = "choro",
       var="np_global",
       breaks = "quantile",
       nbreaks = 5,
       lwd=1,
       add = TRUE)
mf_map(x = st_cast(centreBdx[,c("geom")],"MULTILINESTRING"), 
       lwd=4,
       col="black",add = TRUE)
mf_layout(title = "Lissage avec rayon de 1000m",credits = "Insee-DSAU, XXXX, IGN, mapsf")
```


# Excercice 5 : Lissage de la part de places PMR

```{r echo=TRUE, solution=TRUE}
parkingsLissage <- parkingBuff[,c("np_global","np_pmr","x","y")]

sfcarLisse <- btb::kernelSmoothing(dfObservations = parkingsLissage, 
                                    sEPSG = "2154",
                                    iCellSize = 200, 
                                    iBandwidth = 1500)

sfcarLisse$part_pmf <- sfcarLisse$np_pmr/sfcarLisse$np_global

# Filtrage des carreaux lissés dans Paris
sfcarLisse <- sfcarLisse[unlist(st_intersects(centreBdx,sfcarLisse)),]

# Carte lissée
mf_init(x=sfcarLisse,theme = "agolalight")
mf_map(x = sfcarLisse, 
       type = "choro",
       var="part_pmf",
       breaks = "quantile",
       nbreaks = 5,
       lwd=1,
       add = TRUE)
mf_map(x = st_cast(centreBdx[,c("geom")],"MULTILINESTRING"), 
       lwd=4,
       col="black",add = TRUE)
mf_layout(title = "Lissage avec rayon de 1000m",credits = "Insee-DSAU, XXXX, IGN, mapsf")
```






# Exercice type 

```{block, box.title = "1", box.body = list(fill = "white"), box.icon = "fa-star"}

```

```{block, opts.label = "clues"}
Indices
```

```{block, solution = TRUE}
Solution sans code
```

```{r echo=TRUE, solution=TRUE}

```



--------------------------------------------

--------------------------------------------

**Reproducibilité**

```{r}
sessionInfo()
```

